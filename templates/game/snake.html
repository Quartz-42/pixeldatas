<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Jeu Snake Jungle</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background-color: #f0f0f0;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background-size: 80px 80px;
        background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
      }
      #gameContainer {
        text-align: center;
        background-color: rgba(46, 204, 113, 0.9);
        padding: 20px;
        border-radius: 15px;
      }
      canvas {
        border-radius: 10px;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
        background-color: #f0f0f0;
      }
      #scoreBoard {
        margin-top: 20px;
        font-size: 24px;
        color: #black;
      }
      #gameOverScreen {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        background-color: rgba(46, 204, 113, 0.9);
        color: white;
        padding: 40px;
        border-radius: 20px;
        display: none;
        box-shadow: 0 0 30px rgba(0, 0, 0, 0.3);
      }
      #restartButton {
        margin-top: 20px;
        padding: 15px 30px;
        font-size: 18px;
        cursor: pointer;
        background-color: #f1c40f;
        color: #2c3e50;
        border: none;
        border-radius: 5px;
        transition: background-color 0.3s, transform 0.1s;
      }
      #restartButton:hover {
        background-color: #f39c12;
        transform: scale(1.05);
      }
      #dPad {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-top: 20px;
      }

      .dPadButton {
        width: 60px;
        height: 60px;
        margin: 5px;
        background-color: #3498db;
        color: white;
        font-size: 24px;
        border: none;
        border-radius: 10px;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <div id="gameContainer">
      <canvas id="gameCanvas" width="600" height="600"></canvas>
      <div id="scoreBoard">Score: <span id="score">0</span></div>
      <button id="back" class="mt-5">Retour à l'accueil</button>
      <div id="dPad">
        <button id="up" class="dPadButton">↑</button>
        <div style="display: flex">
          <button id="left" class="dPadButton">←</button>
          <button id="down" class="dPadButton">↓</button>
          <button id="right" class="dPadButton">→</button>
        </div>
      </div>
    </div>
    <div id="gameOverScreen">
      <h1>GAME OVER</h1>
      <p>Score final: <span id="finalScore"></span></p>
      <button id="restartButton">Nouvelle partie</button>
    </div>
    <script>
      const back = document.getElementById("back");
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const scoreElement = document.getElementById("score");
      const gameOverScreen = document.getElementById("gameOverScreen");
      const finalScoreElement = document.getElementById("finalScore");
      const restartButton = document.getElementById("restartButton");

      const gridSize = 20;
      const tileCount = canvas.width / gridSize;

      let snake, dx, dy, apple, bonus, score, speed, gameInterval;

      function initGame() {
        snake = [
          { x: 10, y: 10 },
          { x: 9, y: 10 },
          { x: 8, y: 10 },
        ];
        dx = 1;
        dy = 0;
        apple = getRandomPosition();
        bonus = null;
        score = 0;
        speed = 100;
        scoreElement.textContent = score;
        gameOverScreen.style.display = "none";
        if (gameInterval) clearInterval(gameInterval);
        gameInterval = setInterval(gameLoop, speed);
      }

      function getRandomPosition() {
        return {
          x: Math.floor(Math.random() * tileCount),
          y: Math.floor(Math.random() * tileCount),
        };
      }

      function drawGrid() {
        ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
        for (let i = 0; i < tileCount; i++) {
          for (let j = 0; j < tileCount; j++) {
            if ((i + j) % 2 === 0) {
              ctx.fillRect(i * gridSize, j * gridSize, gridSize, gridSize);
            }
          }
        }
      }

      function drawSnakePart(part, index) {
        const gradient = ctx.createRadialGradient(
          part.x * gridSize + gridSize / 2,
          part.y * gridSize + gridSize / 2,
          0,
          part.x * gridSize + gridSize / 2,
          part.y * gridSize + gridSize / 2,
          gridSize / 2
        );
        gradient.addColorStop(0, "#2ecc71");
        gradient.addColorStop(1, "#27ae60");

        ctx.fillStyle = gradient;
        ctx.beginPath();
        if (index === 0) {
          // Tête du serpent
          ctx.arc(
            part.x * gridSize + gridSize / 2,
            part.y * gridSize + gridSize / 2,
            gridSize / 2,
            0,
            2 * Math.PI
          );
        } else {
          // Corps du serpent
          ctx.ellipse(
            part.x * gridSize + gridSize / 2,
            part.y * gridSize + gridSize / 2,
            gridSize / 2,
            gridSize / 3,
            0,
            0,
            2 * Math.PI
          );
        }
        ctx.fill();

        // Yeux pour la tête
        if (index === 0) {
          ctx.fillStyle = "white";
          ctx.beginPath();
          ctx.arc(
            part.x * gridSize + gridSize / 3,
            part.y * gridSize + gridSize / 3,
            gridSize / 10,
            0,
            2 * Math.PI
          );
          ctx.arc(
            part.x * gridSize + (2 * gridSize) / 3,
            part.y * gridSize + gridSize / 3,
            gridSize / 10,
            0,
            2 * Math.PI
          );
          ctx.fill();
          ctx.fillStyle = "black";
          ctx.beginPath();
          ctx.arc(
            part.x * gridSize + gridSize / 3,
            part.y * gridSize + gridSize / 3,
            gridSize / 20,
            0,
            2 * Math.PI
          );
          ctx.arc(
            part.x * gridSize + (2 * gridSize) / 3,
            part.y * gridSize + gridSize / 3,
            gridSize / 20,
            0,
            2 * Math.PI
          );
          ctx.fill();
        }
      }

      function drawApple() {
        const gradient = ctx.createRadialGradient(
          apple.x * gridSize + gridSize / 2,
          apple.y * gridSize + gridSize / 2,
          0,
          apple.x * gridSize + gridSize / 2,
          apple.y * gridSize + gridSize / 2,
          gridSize / 2
        );
        gradient.addColorStop(0, "#e74c3c");
        gradient.addColorStop(1, "#c0392b");

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(
          apple.x * gridSize + gridSize / 2,
          apple.y * gridSize + gridSize / 2,
          gridSize / 2,
          0,
          2 * Math.PI
        );
        ctx.fill();

        // Tige de la pomme
        ctx.strokeStyle = "#27ae60";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(apple.x * gridSize + gridSize / 2, apple.y * gridSize);
        ctx.lineTo(
          apple.x * gridSize + gridSize / 2,
          apple.y * gridSize - gridSize / 4
        );
        ctx.stroke();
      }

      function drawBonus() {
        if (bonus) {
          const gradient = ctx.createRadialGradient(
            bonus.x * gridSize + gridSize / 2,
            bonus.y * gridSize + gridSize / 2,
            0,
            bonus.x * gridSize + gridSize / 2,
            bonus.y * gridSize + gridSize / 2,
            gridSize / 2
          );
          gradient.addColorStop(0, "#f1c40f");
          gradient.addColorStop(1, "#f39c12");

          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(
            bonus.x * gridSize + gridSize / 2,
            bonus.y * gridSize + gridSize / 2,
            gridSize / 2,
            0,
            2 * Math.PI
          );
          ctx.fill();

          // Étoile sur le bonus
          ctx.fillStyle = "#fff";
          ctx.beginPath();
          ctx.moveTo(
            bonus.x * gridSize + gridSize / 2,
            bonus.y * gridSize + gridSize / 6
          );
          for (let i = 0; i < 5; i++) {
            ctx.lineTo(
              bonus.x * gridSize +
                gridSize / 2 +
                (Math.cos((i * 4 * Math.PI) / 5 + Math.PI / 2) * gridSize) / 3,
              bonus.y * gridSize +
                gridSize / 2 +
                (Math.sin((i * 4 * Math.PI) / 5 + Math.PI / 2) * gridSize) / 3
            );
            ctx.lineTo(
              bonus.x * gridSize +
                gridSize / 2 +
                (Math.cos((i * 4 * Math.PI) / 5 + Math.PI / 5 + Math.PI / 2) *
                  gridSize) /
                  6,
              bonus.y * gridSize +
                gridSize / 2 +
                (Math.sin((i * 4 * Math.PI) / 5 + Math.PI / 5 + Math.PI / 2) *
                  gridSize) /
                  6
            );
          }
          ctx.closePath();
          ctx.fill();
        }
      }

      function move() {
        const head = { x: snake[0].x + dx, y: snake[0].y + dy };
        snake.unshift(head);

        if (head.x === apple.x && head.y === apple.y) {
          score++;
          scoreElement.textContent = score;
          apple = getRandomPosition();
          if (Math.random() < 0.1 && !bonus) {
            bonus = getRandomPosition();
          }
          increaseSpeed(5);
        } else if (bonus && head.x === bonus.x && head.y === bonus.y) {
          score += 10;
          scoreElement.textContent = score;
          bonus = null;
          increaseSpeed(10);
        } else {
          snake.pop();
        }

        // Wrapping around the canvas
        if (head.x < 0) head.x = tileCount - 1;
        if (head.x >= tileCount) head.x = 0;
        if (head.y < 0) head.y = tileCount - 1;
        if (head.y >= tileCount) head.y = 0;

        // Check self-collision
        for (let i = 1; i < snake.length; i++) {
          if (head.x === snake[i].x && head.y === snake[i].y) {
            gameOver();
            return;
          }
        }
      }

      function increaseSpeed(amount) {
        speed = Math.max(30, speed - amount);
        clearInterval(gameInterval);
        gameInterval = setInterval(gameLoop, speed);
      }

      function gameOver() {
        clearInterval(gameInterval);
        finalScoreElement.textContent = score;
        gameOverScreen.style.display = "block";
      }

      function gameLoop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrid();
        move();
        snake.forEach(drawSnakePart);
        drawApple();
        drawBonus();
      }

      restartButton.addEventListener("click", initGame);
      document.getElementById("back").addEventListener("click", function () {
        window.location.href = "{{ path('app_home') }}";
      });
      initGame();
      // Gérer les boutons de la croix directionnelle
      const upButton = document.getElementById("up");
      const downButton = document.getElementById("down");
      const leftButton = document.getElementById("left");
      const rightButton = document.getElementById("right");

      upButton.addEventListener("click", () => {
        if (dy === 0) {
          dx = 0;
          dy = -1;
        }
      });

      downButton.addEventListener("click", () => {
        if (dy === 0) {
          dx = 0;
          dy = 1;
        }
      });

      leftButton.addEventListener("click", () => {
        if (dx === 0) {
          dx = -1;
          dy = 0;
        }
      });

      rightButton.addEventListener("click", () => {
        if (dx === 0) {
          dx = 1;
          dy = 0;
        }
      });
    </script>
  </body>
</html>
